<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üé• WebRTC Live Browser Stream</title>
    <script>
      // Force HTTP protocol and prevent HTTPS upgrades
      if (window.location.protocol === "https:") {
        window.location.href = window.location.href.replace("https:", "http:");
      }

      // Dynamically load socket.io.js with explicit HTTP protocol
      function loadSocketIO() {
        const script = document.createElement("script");
        script.src =
          window.location.protocol +
          "//" +
          window.location.host +
          "/socket.io/socket.io.js";
        script.onload = function () {
          console.log("Socket.IO loaded successfully");
          // Initialize the streaming client after Socket.IO loads
          if (typeof io !== "undefined") {
            window.webRTCClient = new WebRTCStreamingClient();
          }
        };
        script.onerror = function () {
          console.error("Failed to load Socket.IO");
        };
        document.head.appendChild(script);
      }

      // Load Socket.IO when page loads
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", loadSocketIO);
      } else {
        loadSocketIO();
      }
    </script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        background: #000;
        color: #fff;
      }

      .streaming-container {
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #000;
        overflow: hidden;
        position: relative;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      .browser-screen {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #000;
        position: relative;
        border: none;
        border-radius: 0;
        box-shadow: none;
        overflow: hidden;
      }

      #browserCanvas {
        width: 100%;
        height: 100%;
        object-fit: contain;
        border: none;
        cursor: pointer;
        display: block;
        background: #000;
        border-radius: 0;
      }

      .placeholder {
        text-align: center;
        color: #a0aec0;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 10;
      }

      .placeholder h3 {
        font-size: 1.8em;
        margin-bottom: 10px;
        color: #e2e8f0;
      }

      .placeholder p {
        font-size: 1.1em;
        opacity: 0.8;
      }

      /* Ripple animation for click feedback */
      @keyframes ripple {
        0% {
          transform: scale(0);
          opacity: 1;
        }
        100% {
          transform: scale(4);
          opacity: 0;
        }
      }

      /* Tab Management UI Styles */
      .tab-control-button {
        position: fixed;
        top: 15px;
        left: 15px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        border-radius: 25px;
        padding: 10px 15px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
        z-index: 1001;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 5px;
      }

      .tab-control-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        background: linear-gradient(135deg, #7c8ef5 0%, #8659b8 100%);
      }

      .tab-control-button:active {
        transform: translateY(0);
      }

      .tabs-popup {
        position: fixed;
        top: 60px;
        left: 15px;
        background: linear-gradient(
          145deg,
          rgba(30, 30, 30, 0.95),
          rgba(20, 20, 20, 0.95)
        );
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(10px);
        z-index: 1000;
        max-width: 450px;
        min-width: 320px;
        opacity: 0;
        transform: translateY(-10px) scale(0.95);
        transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        pointer-events: none;
      }

      .tabs-popup.show {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: all;
      }

      .tabs-popup-header {
        padding: 15px 20px 10px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .tabs-popup-title {
        font-size: 14px;
        font-weight: 600;
        color: #ffffff;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .tabs-popup-close {
        background: rgba(255, 255, 255, 0.1);
        border: none;
        border-radius: 6px;
        color: white;
        width: 24px;
        height: 24px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
      }

      .tabs-popup-close:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .tabs-list {
        max-height: 300px;
        overflow-y: auto;
        padding: 10px;
      }

      .tabs-list::-webkit-scrollbar {
        width: 6px;
      }

      .tabs-list::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
      }

      .tabs-list::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 3px;
      }

      .tab-item {
        padding: 12px 15px;
        margin: 4px 0;
        border-radius: 8px;
        cursor: pointer;
        border: 1px solid transparent;
        background: transparent;
        transition: all 0.2s ease;
        position: relative;
        overflow: hidden;
      }

      .tab-item:hover {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.2);
        transform: translateX(2px);
      }

      .tab-item.active {
        background: linear-gradient(
          135deg,
          rgba(76, 175, 80, 0.2),
          rgba(56, 142, 60, 0.2)
        );
        border-color: #4caf50;
        box-shadow: 0 2px 10px rgba(76, 175, 80, 0.3);
      }

      .tab-item.active:hover {
        background: linear-gradient(
          135deg,
          rgba(76, 175, 80, 0.3),
          rgba(56, 142, 60, 0.3)
        );
      }

      .tab-title {
        font-size: 13px;
        font-weight: 500;
        color: #ffffff;
        margin-bottom: 4px;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .tab-url {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.6);
        word-break: break-all;
      }

      .active-tab-indicator {
        position: fixed;
        bottom: 20px;
        left: 15px;
        background: linear-gradient(
          135deg,
          rgba(30, 30, 30, 0.9),
          rgba(20, 20, 20, 0.9)
        );
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        padding: 12px 16px;
        z-index: 1000;
        font-size: 12px;
        max-width: 350px;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(8px);
      }

      .active-tab-title {
        font-weight: 600;
        color: #4caf50;
        margin-bottom: 2px;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .active-tab-url {
        color: rgba(255, 255, 255, 0.7);
        font-size: 10px;
      }

      .tab-count {
        background: rgba(255, 255, 255, 0.2);
        color: white;
        font-size: 10px;
        padding: 2px 6px;
        border-radius: 10px;
        font-weight: 500;
      }

      /* Animation for tab switching */
      @keyframes tabSwitch {
        0% {
          opacity: 0.6;
          transform: scale(0.98);
        }
        50% {
          opacity: 0.8;
          transform: scale(1.02);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }

      .tab-switching {
        animation: tabSwitch 0.5s ease-in-out;
      }
    </style>
  </head>
  <body>
    <div class="streaming-container">
      <div class="browser-screen">
        <canvas id="browserCanvas"></canvas>
        <div class="placeholder" id="placeholder">
          <h3>üåê Connecting to Browser Stream</h3>
          <p>Loading...</p>
        </div>

        <!-- Improved Tab Management UI -->
        <button
          id="tabControlButton"
          class="tab-control-button"
          style="display: none"
        >
          üóÇÔ∏è <span id="tabButtonText">Tabs</span>
          <span id="tabCount" class="tab-count">0</span>
        </button>

        <div id="tabsPopup" class="tabs-popup">
          <div class="tabs-popup-header">
            <div class="tabs-popup-title">
              üóÇÔ∏è Browser Tabs
              <span id="popupTabCount" class="tab-count">0</span>
            </div>
            <button id="closeTabsPopup" class="tabs-popup-close">√ó</button>
          </div>
          <div id="tabsList" class="tabs-list">
            <div
              style="
                opacity: 0.7;
                text-align: center;
                padding: 20px;
                color: rgba(255, 255, 255, 0.6);
              "
            >
              Loading tabs...
            </div>
          </div>
        </div>

        <!-- Improved Active Tab Info -->
        <div
          id="activeTabIndicator"
          class="active-tab-indicator"
          style="display: none"
        >
          <div id="activeTabTitle" class="active-tab-title">
            <span>üî∏</span> Loading...
          </div>
          <div id="activeTabUrl" class="active-tab-url">Loading...</div>
        </div>

        <!-- Interaction Status Indicator -->
        <!-- <div
          id="interactionStatus"
          style="
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 255, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-weight: bold;
          "
        >
          ‚úÖ Interactions Ready
        </div> -->

        <!-- Security Blocked Indicator -->
        <div
          id="securityBlocked"
          style="
            display: none;
            position: fixed;
            top: 60px;
            right: 20px;
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            font-weight: bold;
          "
        >
          üö´ Action Blocked
        </div>
      </div>
    </div>

    <script>
      class WebRTCStreamingClient {
        constructor() {
          // Get session ID from URL
          this.sessionId = this.getSessionIdFromUrl();

          // Elements - Full screen canvas only
          this.canvas = document.getElementById("browserCanvas");
          this.ctx = this.canvas.getContext("2d");
          this.placeholder = document.getElementById("placeholder");

          // Stats
          this.frameCount = 0;
          this.currentSession = this.sessionId;

          // Tab management
          this.tabs = [];
          this.activeTabId = null;
          this.isTabsPopupVisible = false;

          // Tab UI elements
          this.tabControlButton = null;
          this.tabsPopup = null;
          this.tabsList = null;
          this.activeTabIndicator = null;

          // WebRTC components
          this.peerConnection = null;
          this.localStream = null;
          this.remoteStream = null;

          this.init();
        }

        getSessionIdFromUrl() {
          // Try URL params first
          const urlParams = new URLSearchParams(window.location.search);
          let sessionId = urlParams.get("sessionId");

          // If not in params, try to extract from path
          if (!sessionId) {
            const pathParts = window.location.pathname.split("/");
            sessionId = pathParts[pathParts.length - 1];
          }

          return sessionId || "unknown";
        }

        init() {
          this.setupCanvas();
          this.connect();

          // Debug canvas dimensions
          setTimeout(() => {
            const rect = this.canvas.getBoundingClientRect();
            console.log("üîß Canvas Info:");
            console.log(
              `üñ•Ô∏è Internal: ${this.canvas.width}x${this.canvas.height}`,
            );
            console.log(
              `üì± Display: ${rect.width.toFixed(1)}x${rect.height.toFixed(1)}`,
            );
            console.log("üéØ Ready for interactions!");
          }, 1000);
        }

        // High-quality canvas setup with proper aspect ratio handling
        setupCanvas() {
          // Enable high-quality rendering
          this.ctx.imageSmoothingEnabled = true;
          this.ctx.imageSmoothingQuality = "high";

          // Set FIXED canvas size - always use 1920x1080 for consistent streaming
          this.canvas.width = 1920;
          this.canvas.height = 1080;

          this.img = new Image();
          this.img.onload = () => {
            // IMPORTANT: Always maintain 1920x1080 canvas dimensions
            // Do NOT resize canvas based on image - keep it fixed
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.drawImage(
              this.img,
              0,
              0,
              this.canvas.width,
              this.canvas.height,
            );
          };

          // Add interactive event listeners
          this.setupCanvasInteractions();

          // Handle window resize with debouncing
          let resizeTimeout = null;
          window.addEventListener("resize", () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
              this.updateCanvasDimensions();
            }, 300);
          });
        }

        // Update canvas dimensions to maintain aspect ratio for iframe embedding
        updateCanvasDimensions() {
          const container = this.canvas.parentElement;
          const containerRect = container.getBoundingClientRect();

          // FIXED: Use consistent display size for streaming consistency
          const FIXED_DISPLAY_WIDTH = Math.min(
            1280,
            containerRect.width * 0.95,
          );
          const FIXED_DISPLAY_HEIGHT = (FIXED_DISPLAY_WIDTH * 1080) / 1920;

          // Ensure we don't exceed container height
          const maxHeight = containerRect.height * 0.9;
          let displayWidth = FIXED_DISPLAY_WIDTH;
          let displayHeight = FIXED_DISPLAY_HEIGHT;

          if (displayHeight > maxHeight) {
            displayHeight = maxHeight;
            displayWidth = (displayHeight * 1920) / 1080;
          }

          // Set canvas display size to fixed dimensions for consistency
          this.canvas.style.width = `${displayWidth}px`;
          this.canvas.style.height = `${displayHeight}px`;

          // Center the canvas in the container
          this.canvas.style.position = "absolute";
          this.canvas.style.left = "50%";
          this.canvas.style.top = "50%";
          this.canvas.style.transform = "translate(-50%, -50%)";

          // ALWAYS keep internal canvas resolution at 1920x1080 for maximum quality
          this.canvas.width = 1920;
          this.canvas.height = 1080;

          console.log(
            `üìê Canvas FIXED STREAMING SIZE - Display: ${displayWidth.toFixed(1)}x${displayHeight.toFixed(1)}, Internal: 1920x1080`,
          );
        }

        // Full mouse interaction system
        setupCanvasInteractions() {
          let isDragging = false;
          let lastMousePosition = { x: 0, y: 0 };
          let dragStartPosition = { x: 0, y: 0 };
          let mouseButtonPressed = null; // Track which button is pressed
          let mouseDownSent = false; // Track if mousedown was sent

          // Mouse down events
          this.canvas.addEventListener("mousedown", (e) => {
            if (!this.currentSession) return;

            const coords = this.getScaledCoordinates(e);
            if (!coords) return;

            isDragging = false; // Reset on new mousedown
            mouseButtonPressed = e.button === 0 ? "left" : e.button === 2 ? "right" : "middle";
            mouseDownSent = true;
            dragStartPosition = { x: coords.x, y: coords.y };
            lastMousePosition = { x: coords.x, y: coords.y };

            this.sendMouseEvent("mousedown", coords.x, coords.y, 0, 0, mouseButtonPressed);
          });

          // Mouse move events with throttling for better performance
          let moveTimeout = null;
          this.canvas.addEventListener("mousemove", (e) => {
            if (!this.currentSession) return;

            const coords = this.getScaledCoordinates(e);
            if (!coords) return;

            // Check if we're actually dragging
            if (mouseButtonPressed && mouseDownSent) {
              const dragDistance = Math.sqrt(
                Math.pow(coords.x - dragStartPosition.x, 2) +
                Math.pow(coords.y - dragStartPosition.y, 2)
              );
              if (dragDistance > 3) {
                isDragging = true;
              }
            }

            // Throttle mouse move events for better performance
            if (moveTimeout) return;

            if (
              isDragging ||
              Math.abs(coords.x - lastMousePosition.x) > 5 ||
              Math.abs(coords.y - lastMousePosition.y) > 5
            ) {
              moveTimeout = setTimeout(() => {
                this.sendMouseEvent("mousemove", coords.x, coords.y);
                lastMousePosition = { x: coords.x, y: coords.y };
                moveTimeout = null;
              }, 16); // ~60fps throttling
            }
          });

          // Mouse up events
          this.canvas.addEventListener("mouseup", (e) => {
            if (!this.currentSession) return;

            const coords = this.getScaledCoordinates(e);
            if (!coords) {
              this.resetMouseState();
              return;
            }

            const button = e.button === 0 ? "left" : e.button === 2 ? "right" : "middle";

            // Only send mouseup if we sent a corresponding mousedown
            if (mouseDownSent && mouseButtonPressed === button) {
              this.sendMouseEvent("mouseup", coords.x, coords.y, 0, 0, button);
              
              // If it wasn't a drag, send a click
              if (!isDragging) {
                setTimeout(() => {
                  this.sendMouseEvent("click", coords.x, coords.y, 0, 0, button);
                }, 10);
              }
            }

            this.resetMouseState();
          });

          // Reset mouse state helper
          this.resetMouseState = () => {
            isDragging = false;
            mouseButtonPressed = null;
            mouseDownSent = false;
          };

          // Mouse leave - reset state when mouse leaves canvas
          this.canvas.addEventListener("mouseleave", () => {
            this.resetMouseState();
          });

          // Context menu prevention
          this.canvas.addEventListener("contextmenu", (e) => {
            e.preventDefault();
          });

          // Mouse wheel events
          this.canvas.addEventListener("wheel", (e) => {
            if (!this.currentSession) return;
            e.preventDefault();

            const coords = this.getScaledCoordinates(e);
            if (!coords) return;

            const deltaX = e.deltaX || 0;
            const deltaY = e.deltaY || 0;

            this.sendMouseEvent("scroll", coords.x, coords.y, deltaX, deltaY);
          });

          // Prevent context menu on right click
          this.canvas.addEventListener("contextmenu", (e) => {
            e.preventDefault();
          });

          // Keyboard events
          window.addEventListener("keydown", (e) => {
            if (!this.currentSession) return;

            if (
              e.target.tagName === "INPUT" ||
              e.target.tagName === "TEXTAREA"
            ) {
              return;
            }

            if (e.key.length > 1 || e.ctrlKey || e.altKey || e.metaKey) {
              e.preventDefault();
              this.sendKeyboardEvent("keydown", e.key);
              return;
            }

            if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
              e.preventDefault();
              this.sendKeyboardEvent("type", "", e.key);
            }
          });

          window.addEventListener("keyup", (e) => {
            if (!this.currentSession) return;

            if (
              e.target.tagName === "INPUT" ||
              e.target.tagName === "TEXTAREA"
            ) {
              return;
            }

            if (e.key.length > 1 || e.ctrlKey || e.altKey || e.metaKey) {
              e.preventDefault();
              this.sendKeyboardEvent("keyup", e.key);
            }
          });
        }

        // Precise coordinate scaling with aspect ratio consideration
        getScaledCoordinates(e) {
          const rect = this.canvas.getBoundingClientRect();

          // Get raw click position relative to canvas
          const rawClickX = e.clientX - rect.left;
          const rawClickY = e.clientY - rect.top;

          // Use actual canvas internal dimensions for accurate mapping
          const canvasWidth = this.canvas.width;
          const canvasHeight = this.canvas.height;

          // Direct coordinate mapping from display to canvas internal coordinates
          const x = (rawClickX / rect.width) * canvasWidth;
          const y = (rawClickY / rect.height) * canvasHeight;

          // Ensure coordinates are within bounds
          const clampedX = Math.max(0, Math.min(canvasWidth - 1, x));
          const clampedY = Math.max(0, Math.min(canvasHeight - 1, y));

          // Debug coordinate transformation (reduced logging)
          if (e.type === "click" || e.type === "mousedown") {
            console.log(
              `üéØ Click: Display(${rawClickX.toFixed(1)}, ${rawClickY.toFixed(1)}) ‚Üí Canvas(${clampedX.toFixed(1)}, ${clampedY.toFixed(1)}) | Canvas: ${canvasWidth}x${canvasHeight} | Display: ${rect.width.toFixed(1)}x${rect.height.toFixed(1)}`,
            );
          }

          return {
            x: clampedX,
            y: clampedY,
          };
        }

        // Send mouse events to server
        sendMouseEvent(type, x, y, deltaX = 0, deltaY = 0, button = "left") {
          if (!this.socket || !this.currentSession) {
            console.warn("Cannot send mouse event - no socket or session");
            return;
          }

          // Validate coordinates
          if (
            x < 0 ||
            y < 0 ||
            isNaN(x) ||
            isNaN(y) ||
            x >= this.canvas.width ||
            y >= this.canvas.height
          ) {
            console.warn("Invalid coordinates:", {
              x,
              y,
              canvasWidth: this.canvas.width,
              canvasHeight: this.canvas.height,
            });
            return;
          }

          const preciseX = Math.round(x);
          const preciseY = Math.round(y);

          // Only log for important events to reduce console spam
          if (type === "click" || type === "mousedown") {
            console.log(
              `üñ±Ô∏è Sending ${type} event to (${preciseX}, ${preciseY})`,
            );
          }

          this.socket.emit("mouse-event", {
            type,
            x: preciseX,
            y: preciseY,
            deltaX: Math.round(deltaX),
            deltaY: Math.round(deltaY),
            button,
            timestamp: Date.now(),
          });

          // Visual feedback for clicks removed - no red circle on click
        }

        // Send keyboard events
        sendKeyboardEvent(type, key, text = "") {
          if (!this.socket || !this.currentSession) return;

          if (type === "type" && text.length === 0) return;

          this.socket.emit("keyboard-event", {
            type,
            key,
            text,
            timestamp: Date.now(),
          });
        }

        // Visual click feedback - DISABLED
        // showClickFeedback(x, y) {
        //   // Click feedback has been disabled per user request
        // }

        // Show security blocked message
        showSecurityBlocked(message) {
          const blockedIndicator = document.getElementById("securityBlocked");
          if (blockedIndicator) {
            blockedIndicator.textContent = `üö´ ${message}`;
            blockedIndicator.style.display = "block";

            // Hide after 3 seconds
            setTimeout(() => {
              blockedIndicator.style.display = "none";
            }, 3000);
          }

          console.warn("üö´ Security action blocked:", message);
        }

        // Prevent browser/tab closure
        preventBrowserClosure() {
          window.addEventListener("beforeunload", (e) => {
            e.preventDefault();
            e.returnValue =
              "‚ö†Ô∏è Closing this tab will end your session. Are you sure?";
            return e.returnValue;
          });

          // Prevent right-click context menu
          document.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            this.showSecurityBlocked("Right-click context menu disabled");
            return false;
          });

          // Prevent F5 refresh
          document.addEventListener("keydown", (e) => {
            if (e.key === "F5" || (e.ctrlKey && e.key === "r")) {
              e.preventDefault();
              this.showSecurityBlocked(
                "Page refresh blocked for session security",
              );
              return false;
            }
          });

          console.log("üîí Browser closure protection enabled");
        }

        connect() {
          try {
            this.socket = io({
              transports: ["polling", "websocket"],
              upgrade: true,
              rememberUpgrade: false,
              forceNew: true,
              secure: false,
              rejectUnauthorized: false,
            });

            this.setupSocketEvents();
          } catch (error) {
            console.error("Failed to connect:", error);
          }
        }

        setupSocketEvents() {
          this.socket.on("connect", () => {
            console.log("Connected to server");
            console.log("Attempting to join session:", this.sessionId);
            this.socket.emit("join-session", { sessionId: this.sessionId });
          });

          this.socket.on("disconnect", () => {
            console.log("Disconnected from server");

            // Clean up tab refresh interval
            if (this.tabRefreshInterval) {
              clearInterval(this.tabRefreshInterval);
              this.tabRefreshInterval = null;
            }
          });

          this.socket.on("session-joined", (data) => {
            console.log("Session joined:", data);
            this.currentSession = data.sessionId || this.sessionId;
            this.enableSessionControls();
            // Request initial frame to start the stream
            this.requestInitialFrame();
          });

          // WebRTC Signaling Events
          this.socket.on("webrtc-offer", (offer) => {
            this.handleOffer(offer);
          });

          this.socket.on("webrtc-answer", (answer) => {
            this.handleAnswer(answer);
          });

          this.socket.on("webrtc-ice-candidate", (candidate) => {
            this.handleIceCandidate(candidate);
          });

          // Canvas stream started event
          this.socket.on("canvas-stream-started", (data) => {
            console.log("üé® Canvas stream started:", data);
            this.placeholder.textContent = "Loading stream...";
          });

          // Canvas-based video frame handling
          this.socket.on("video-frame", (frameData) => {
            this.frameCount++;
            console.log(
              `üìπ Received video frame ${this.frameCount}: ${typeof frameData === "string" ? frameData.length + " chars" : frameData.length + " bytes"}`,
            );

            // Handle both string (base64) and object formats
            let base64Frame;
            if (typeof frameData === "string") {
              base64Frame = frameData;
            } else if (frameData && frameData.data) {
              base64Frame = frameData.data;
            } else {
              console.warn("Unexpected frame data format:", typeof frameData);
              return;
            }

            this.img.src = "data:image/jpeg;base64," + base64Frame;
            this.placeholder.style.display = "none";

            if (!this.currentSession) {
              this.currentSession = this.sessionId;
              this.enableSessionControls();
            }
          });

          this.socket.on("error", (error) => {
            console.error("Socket error:", error);
          });

          // Handle blocked keyboard shortcuts
          this.socket.on("keyboard-blocked", (data) => {
            console.warn("üö´ Keyboard shortcut blocked:", data);
            this.showSecurityBlocked(data.message);
          });

          // ===== TAB MANAGEMENT EVENTS =====

          // Available tabs received
          this.socket.on("available-tabs", (data) => {
            console.log("üìë Received available tabs:", data);
            console.log(
              "üìë Raw tabs data structure:",
              JSON.stringify(data, null, 2),
            );

            this.tabs = data.tabs || [];
            
            // Find and sync active tab ID from server data or tab.active flag
            const activeTab = this.tabs.find(tab => tab.active) || 
                             (data.activeTabId ? this.tabs.find(tab => 
                               tab.id === data.activeTabId || 
                               tab.id.substring(0, 8) === data.activeTabId
                             ) : null);
            
            if (activeTab) {
              if (this.activeTabId !== activeTab.id) {
                this.activeTabId = activeTab.id;
                console.log(`üîÑ Synced active tab: ${activeTab.title} (${activeTab.id.substring(0, 8)})`);
              }
            } else if (data.activeTabId) {
              this.activeTabId = data.activeTabId; // Fallback
            }

            // Debug tab IDs and structure
            this.tabs.forEach((tab, index) => {
              console.log(
                `üìë Tab ${index}: ID="${tab.id.substring(0, 8)}...", active=${tab.active}, title="${tab.title}"`,
              );
            });

            console.log(`üìë Active Tab ID from server: ${this.activeTabId ? this.activeTabId.substring(0, 8) + '...' : 'none'}`);

            this.updateTabsUI();
          });

          // Tab switched successfully
          this.socket.on("tab-switched", (data) => {
            console.log("üîÑ Tab switched successfully:", data);

            // Handle both short and full tab IDs
            const targetTab = this.tabs.find(tab => 
              tab.id === data.tabId || 
              tab.id.substring(0, 8) === data.tabId ||
              data.tabId.includes(tab.id.substring(0, 8))
            );
            
            if (targetTab) {
              this.activeTabId = targetTab.id; // Store full ID
              console.log(`üéØ Set active tab: ${targetTab.title} (${targetTab.id.substring(0, 8)})`);
            } else {
              this.activeTabId = data.tabId; // Fallback
            }

            // Update active tab info if provided
            if (data.activeTab) {
              this.updateActiveTabInfo(data.activeTab);
            }

            // Refresh tabs list to update UI
            this.requestAvailableTabs();

            // Remove switching animation from all tabs
            if (this.tabsList) {
              this.tabsList
                .querySelectorAll(".tab-switching")
                .forEach((tab) => {
                  tab.classList.remove("tab-switching");
                });
            }

            // Show success feedback
            this.showTabSwitchFeedback(
              "‚úÖ Tab switched successfully",
              "success",
            );

            console.log(`‚úÖ Successfully switched to tab: ${data.tabId}`);
          });

          // Tab changed (broadcast from other clients)
          this.socket.on("tab-changed", (data) => {
            console.log("üì¢ Tab changed (broadcast):", data);

            // Update active tab tracking
            this.activeTabId = data.activeTabId;
            this.updateActiveTabInfo(data.activeTab);

            // Refresh tabs list to update UI
            this.requestAvailableTabs();

            console.log(`üì¢ Tab changed via broadcast to: ${data.activeTabId}`);
          });

          // Active tab info received
          this.socket.on("active-tab-info", (data) => {
            console.log("üìã Active tab info:", data);
            this.updateActiveTabInfo(data.activeTab);
          });

          // Tab switch error
          this.socket.on("tab-switch-error", (data) => {
            console.error("‚ùå Tab switch failed:", data);
            this.showTabSwitchFeedback(
              `‚ùå Failed to switch tab: ${data.message}`,
              "error",
            );

            // Remove switching animation from all tabs
            this.tabsList.querySelectorAll(".tab-switching").forEach((tab) => {
              tab.classList.remove("tab-switching");
            });
          });
        }

        requestCanvasStream() {
          try {
            console.log(
              "üé® Requesting canvas stream for session:",
              this.sessionId,
            );
            this.socket.emit("request-canvas-stream", {
              sessionId: this.sessionId,
            });
          } catch (error) {
            console.error("Failed to request canvas stream:", error);
          }
        }

        requestInitialFrame() {
          try {
            console.log(
              "üé® Requesting initial frame for session:",
              this.sessionId,
            );
            this.socket.emit("request-frame", {
              sessionId: this.sessionId,
            });
          } catch (error) {
            console.error("Failed to request initial frame:", error);
          }
        }

        async initWebRTC() {
          try {
            console.log("Initializing WebRTC...");

            this.peerConnection = new RTCPeerConnection({
              iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
            });

            this.peerConnection.ontrack = (event) => {
              console.log("Received remote stream");
              this.remoteStream = event.streams[0];
              this.setupVideoStream();
              this.placeholder.style.display = "none";
            };

            this.peerConnection.onicecandidate = (event) => {
              if (event.candidate) {
                this.socket.emit("webrtc-ice-candidate", {
                  sessionId: this.sessionId,
                  candidate: event.candidate,
                });
              }
            };

            this.socket.emit("request-webrtc-stream", {
              sessionId: this.sessionId,
            });
          } catch (error) {
            console.error("WebRTC initialization failed:", error);
            this.socket.emit("request-canvas-stream", {
              sessionId: this.sessionId,
            });
          }
        }

        async handleOffer(offer) {
          try {
            await this.peerConnection.setRemoteDescription(offer);
            const answer = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(answer);

            this.socket.emit("webrtc-answer", {
              sessionId: this.sessionId,
              answer: answer,
            });
          } catch (error) {
            console.error("Failed to handle WebRTC offer:", error);
          }
        }

        async handleAnswer(answer) {
          try {
            await this.peerConnection.setRemoteDescription(answer);
          } catch (error) {
            console.error("Failed to handle WebRTC answer:", error);
          }
        }

        async handleIceCandidate(candidate) {
          try {
            await this.peerConnection.addIceCandidate(candidate);
          } catch (error) {
            console.error("Failed to add ICE candidate:", error);
          }
        }

        setupVideoStream() {
          const video = document.createElement("video");
          video.srcObject = this.remoteStream;
          video.autoplay = true;
          video.muted = true;
          video.style.display = "none";

          video.setAttribute("playsinline", true);
          video.setAttribute("webkit-playsinline", true);

          document.body.appendChild(video);

          const drawFrame = () => {
            if (video.readyState >= 2) {
              this.frameCount++;

              // ENHANCED: Maximum quality image smoothing
              this.ctx.imageSmoothingEnabled = true;
              this.ctx.imageSmoothingQuality = "high";

              // ENHANCED: Additional quality settings for crisp rendering
              this.ctx.globalCompositeOperation = "source-over";
              this.ctx.filter = "contrast(1.05) saturate(1.02)"; // Slight enhancement

              this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
              this.ctx.drawImage(
                video,
                0,
                0,
                this.canvas.width,
                this.canvas.height,
              );

              // Reset filter to avoid affecting other drawings
              this.ctx.filter = "none";
            }
            requestAnimationFrame(drawFrame);
          };

          video.addEventListener("loadedmetadata", () => {
            console.log("Video metadata loaded, starting rendering");
            drawFrame();
          });

          video.addEventListener("loadeddata", () => {
            console.log("Video data loaded");
            this.placeholder.style.display = "none";
          });
        }

        enableSessionControls() {
          console.log("‚úÖ Session controls enabled for:", this.currentSession);
          this.canvas.style.cursor = "pointer";

          // Show interaction status
          console.log("üéØ User interactions are now active!");
          console.log(
            "üñ±Ô∏è Click, scroll, and type on the canvas to control the remote browser",
          );

          // Show visual indicator
          const statusIndicator = document.getElementById("interactionStatus");
          if (statusIndicator) {
            statusIndicator.style.display = "block";
          }

          // Enable tab management
          this.initializeTabManagement();

          // Enable browser closure protection
          this.preventBrowserClosure();

          // Test interaction readiness
          setTimeout(() => {
            if (this.currentSession && this.socket?.connected) {
              console.log(
                "‚úÖ Ready for user interactions - try clicking on form fields!",
              );
            }
          }, 1000);
        }

        // ===== TAB MANAGEMENT METHODS =====

        initializeTabManagement() {
          console.log("üóÇÔ∏è Initializing enhanced tab management...");

          // Get UI elements
          this.tabControlButton = document.getElementById("tabControlButton");
          this.tabsPopup = document.getElementById("tabsPopup");
          this.tabsList = document.getElementById("tabsList");
          this.activeTabIndicator =
            document.getElementById("activeTabIndicator");

          // Show tab control button
          this.tabControlButton.style.display = "flex";
          this.activeTabIndicator.style.display = "block";

          // Setup event listeners
          this.setupTabUIEventListeners();

          // Request initial tabs and active tab info
          this.requestAvailableTabs();
          this.requestActiveTabInfo();

          // Refresh tabs periodically
          this.tabRefreshInterval = setInterval(() => {
            if (this.currentSession && this.socket?.connected) {
              this.requestAvailableTabs();
            }
          }, 5000); // Every 5 seconds
        }

        setupTabUIEventListeners() {
          // Tab control button click
          this.tabControlButton.addEventListener("click", (e) => {
            e.stopPropagation();
            this.toggleTabsPopup();
          });

          // Close popup button
          document
            .getElementById("closeTabsPopup")
            .addEventListener("click", (e) => {
              e.stopPropagation();
              this.hideTabsPopup();
            });

          // Click outside to close popup
          document.addEventListener("click", (e) => {
            if (
              this.isTabsPopupVisible &&
              !this.tabsPopup.contains(e.target) &&
              !this.tabControlButton.contains(e.target)
            ) {
              this.hideTabsPopup();
            }
          });

          // Prevent popup from closing when clicking inside it
          this.tabsPopup.addEventListener("click", (e) => {
            e.stopPropagation();
          });

          // Escape key to close popup
          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape" && this.isTabsPopupVisible) {
              this.hideTabsPopup();
            }
          });
        }

        toggleTabsPopup() {
          if (this.isTabsPopupVisible) {
            this.hideTabsPopup();
          } else {
            this.showTabsPopup();
          }
        }

        showTabsPopup() {
          if (!this.tabsPopup) return;

          this.isTabsPopupVisible = true;
          this.tabsPopup.classList.add("show");

          // Refresh tabs when opening popup
          this.requestAvailableTabs();

          // Update button appearance
          this.tabControlButton.style.background =
            "linear-gradient(135deg, #4CAF50 0%, #45a049 100%)";

          console.log("üìñ Tabs popup opened");
        }

        hideTabsPopup() {
          if (!this.tabsPopup) return;

          this.isTabsPopupVisible = false;
          this.tabsPopup.classList.remove("show");

          // Reset button appearance
          this.tabControlButton.style.background =
            "linear-gradient(135deg, #667eea 0%, #764ba2 100%)";

          console.log("üìï Tabs popup closed");
        }

        requestAvailableTabs() {
          if (!this.socket || !this.currentSession) return;

          this.socket.emit("get-available-tabs", {
            sessionId: this.currentSession,
          });
        }

        requestActiveTabInfo() {
          if (!this.socket || !this.currentSession) return;

          this.socket.emit("get-active-tab", {
            sessionId: this.currentSession,
          });
        }

        switchToTab(tabId) {
          if (!this.socket || !this.currentSession) {
            console.error(
              "‚ùå [TAB SWITCH] Cannot switch tab - no socket or session",
            );
            console.log("Socket connected:", this.socket?.connected);
            console.log("Current session:", this.currentSession);
            this.showTabSwitchFeedback(
              "‚ùå Cannot switch tab - connection issue",
              "error",
            );
            return;
          }

          // Find the tab by either full ID or short ID
          const targetTab = this.tabs.find(tab => 
            tab.id === tabId || 
            tab.id.substring(0, 8) === tabId ||
            tabId.includes(tab.id.substring(0, 8))
          );
          
          if (!targetTab) {
            console.error(`‚ùå [TAB SWITCH] Tab ${tabId} not found in current tabs`);
            this.showTabSwitchFeedback("‚ùå Tab not found", "error");
            return;
          }

          console.log(`üîÑ [TAB SWITCH] Switching to tab: ${tabId}`);
          console.log(`üîÑ [TAB SWITCH] Target tab full ID: ${targetTab.id}`);
          console.log(`üîÑ [TAB SWITCH] Session ID: ${this.currentSession}`);
          console.log(
            `üîÑ [TAB SWITCH] Socket connected: ${this.socket.connected}`,
          );

          // Add visual feedback for switching
          const tabElement = this.tabsList.querySelector(
            `[data-tab-id="${targetTab.id}"]`,
          );
          if (tabElement) {
            tabElement.classList.add("tab-switching");
          }

          // Show loading feedback
          this.showTabSwitchFeedback("üîÑ Switching tabs...", "success");

          // Send the FULL tab ID to the server (this is what the server expects)
          this.socket.emit("switch-to-tab", {
            sessionId: this.currentSession,
            tabId: targetTab.id, // Use full ID for server communication
          });

          console.log(
            `üì§ [TAB SWITCH] Sent switch-to-tab event for tab ${targetTab.id}`,
          );

          // Hide popup after switching (with a delay to see the feedback)
          setTimeout(() => {
            this.hideTabsPopup();
          }, 500);
        }

        updateTabsUI() {
          if (!this.tabsList) return;

          this.tabsList.innerHTML = "";

          // Update tab counts
          const tabCount = this.tabs.length;
          document.getElementById("tabCount").textContent = tabCount;
          document.getElementById("popupTabCount").textContent = tabCount;

          // Update button text
          const buttonText = document.getElementById("tabButtonText");
          buttonText.textContent = tabCount === 1 ? "Tab" : "Tabs";

          if (this.tabs.length === 0) {
            this.tabsList.innerHTML = `
              <div style="
                opacity: 0.7; 
                text-align: center; 
                padding: 30px 20px; 
                color: rgba(255,255,255,0.6);
                font-style: italic;
              ">
                üîç No tabs found
                <div style="font-size: 10px; margin-top: 5px;">
                  Try refreshing or opening a new browser session
                </div>
              </div>
            `;
            return;
          }

          this.tabs.forEach((tab, index) => {
            const tabElement = document.createElement("div");
            
            // Improved active state detection
            const isActive = tab.active || 
                           tab.id === this.activeTabId ||
                           (this.activeTabId && tab.id.substring(0, 8) === this.activeTabId.substring(0, 8));
                           
            tabElement.className = `tab-item ${isActive ? "active" : ""}`;

            // Ensure we use the correct tab ID - backend uses 'id' consistently
            const tabIdToUse = tab.id;
            tabElement.setAttribute("data-tab-id", tabIdToUse);

            const favicon = tab.favIconUrl
              ? `<img src="${tab.favIconUrl}" style="width: 16px; height: 16px; margin-right: 4px;" onerror="this.style.display='none'">`
              : "";

            tabElement.innerHTML = `
              <div class="tab-title">
                ${isActive ? "üü¢" : "‚ö™"} 
                ${favicon}
                ${this.truncateText(tab.title || "Untitled Tab", 35)}
              </div>
              <div class="tab-url">
                ${this.truncateText(tab.url || "about:blank", 50)}
              </div>
            `;

            tabElement.addEventListener("click", () => {
              console.log(
                `üñ±Ô∏è [TAB CLICK] Tab clicked: ${tab.id.substring(0, 8)}..., active: ${isActive}`,
              );
              console.log(`üñ±Ô∏è [TAB CLICK] Tab title: ${tab.title}`);
              console.log(
                `üñ±Ô∏è [TAB CLICK] Current session: ${this.currentSession}`,
              );

              if (!isActive) {
                // Use the tab.id directly - backend expects this exact format
                console.log(
                  `üì§ [TAB CLICK] Initiating switch to tab: ${tab.id.substring(0, 8)}...`,
                );
                this.switchToTab(tab.id);
              } else {
                console.log(
                  `‚è≠Ô∏è [TAB CLICK] Tab is already active, closing popup`,
                );
                this.hideTabsPopup();
              }
            });

            // Add hover effects
            tabElement.addEventListener("mouseenter", () => {
              if (!tab.active) {
                tabElement.style.transform = "translateX(4px)";
              }
            });

            tabElement.addEventListener("mouseleave", () => {
              tabElement.style.transform = "translateX(0)";
              tabElement.classList.remove("tab-switching");
            });

            this.tabsList.appendChild(tabElement);
          });
        }

        updateActiveTabInfo(activeTab) {
          if (!this.activeTabIndicator) return;

          const titleElement = document.getElementById("activeTabTitle");
          const urlElement = document.getElementById("activeTabUrl");

          if (titleElement && urlElement) {
            if (activeTab) {
              const favicon = activeTab.favIconUrl
                ? `<img src="${activeTab.favIconUrl}" style="width: 14px; height: 14px; margin-right: 4px;" onerror="this.style.display='none'">`
                : "üî∏";

              titleElement.innerHTML = `
                <span>${favicon}</span>
                ${this.truncateText(activeTab.title || "Untitled Tab", 40)}
              `;
              urlElement.textContent = this.truncateText(
                activeTab.url || "about:blank",
                55,
              );
            } else {
              titleElement.innerHTML = "<span>üî∏</span> No active tab";
              urlElement.textContent = "Waiting for tab information...";
            }
          }
        }

        truncateText(text, maxLength) {
          if (!text) return "";
          return text.length > maxLength
            ? text.substring(0, maxLength) + "..."
            : text;
        }

        showTabSwitchFeedback(message, type = "success") {
          // Create or update feedback element
          let feedback = document.getElementById("tabSwitchFeedback");
          if (!feedback) {
            feedback = document.createElement("div");
            feedback.id = "tabSwitchFeedback";
            feedback.style.cssText = `
              position: fixed;
              top: 70px;
              right: 20px;
              padding: 10px 15px;
              border-radius: 8px;
              font-size: 12px;
              font-weight: 600;
              z-index: 1001;
              opacity: 0;
              transform: translateX(20px);
              transition: all 0.3s ease;
              max-width: 250px;
            `;
            document.body.appendChild(feedback);
          }

          // Set style based on type
          if (type === "success") {
            feedback.style.background =
              "linear-gradient(135deg, #4CAF50, #45a049)";
            feedback.style.color = "white";
          } else {
            feedback.style.background =
              "linear-gradient(135deg, #f44336, #d32f2f)";
            feedback.style.color = "white";
          }

          feedback.textContent = message;

          // Show feedback
          feedback.style.opacity = "1";
          feedback.style.transform = "translateX(0)";

          // Hide after 3 seconds
          setTimeout(() => {
            if (feedback) {
              feedback.style.opacity = "0";
              feedback.style.transform = "translateX(20px)";

              setTimeout(() => {
                if (feedback && feedback.parentNode) {
                  feedback.parentNode.removeChild(feedback);
                }
              }, 300);
            }
          }, 3000);
        }
      }
      
      // Make client globally accessible for debugging
      window.webRTCClient = null;
      
      // Global helper functions for debugging
      window.switchToTab = (tabId) => {
        if (window.webRTCClient) {
          window.webRTCClient.switchToTab(tabId);
        } else {
          console.error('WebRTC Client not initialized');
        }
      };
      
      window.debugTabs = () => {
        if (window.webRTCClient && window.webRTCClient.tabs) {
          console.log('Current tabs:', window.webRTCClient.tabs.map(tab => ({
            shortId: tab.id.substring(0, 8),
            fullId: tab.id,
            title: tab.title,
            active: tab.active,
            isCurrentActive: tab.id === window.webRTCClient.activeTabId
          })));
          console.log('Current activeTabId:', window.webRTCClient.activeTabId);
        }
      };
      
      window.refreshTabs = () => {
        if (window.webRTCClient) {
          window.webRTCClient.requestAvailableTabs();
          console.log('üîÑ Requested tab refresh');
        }
      };
    </script>
  </body>
</html>
